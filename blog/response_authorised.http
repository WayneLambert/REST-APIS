HTTP/1.1 200 OK
Date: Sat, 13 Apr 2019 12:57:40 GMT
Server: WSGIServer/0.2 CPython/3.7.1
Content-Type: application/json
Vary: Accept, Cookie, Origin
Allow: GET, POST, HEAD, OPTIONS
X-Frame-Options: SAMEORIGIN
Content-Length: 3280

[{"id":1,"title":"PEP 570 -- Python Positional-Only Parameters","body":"This PEP proposes to introduce a new syntax, /, for specifying positional-only parameters in Python function definitions.\r\n\r\nPositional-only parameters have no externally-usable name. When a function accepting positional-only parameters is called, positional arguments are mapped to these parameters based solely on their order.\r\n\r\nWhen designing APIs (application programming interfaces), library authors try to ensure correct and intended usage of an API. Without the ability to specify which parameters are positional-only, library authors must be careful when choosing appropriate parameter names. This care must be taken even for required parameters or when the parameters have no external semantic meaning for callers of the API.","author":2,"publish_date":"2019-04-11T18:56:40.153900Z","updated_date":"2019-04-11T18:56:40.153918Z"},{"id":2,"title":"PEP 572 -- Assignment Expressions","body":"This is a proposal for creating a way to assign to variables within an expression using the notation NAME := expr. A new exception, TargetScopeError is added, and there is one change to evaluation order.\r\n\r\naming the result of an expression is an important part of programming, allowing a descriptive name to be used in place of a longer expression, and permitting reuse. Currently, this feature is available only in statement form, making it unavailable in list comprehensions and other expression contexts.\r\n\r\nAdditionally, naming sub-parts of a large expression can assist an interactive debugger, providing useful display hooks and partial results. Without a way to capture sub-expressions inline, this would require refactoring of the original code; with assignment expressions, this merely requires the insertion of a few name := markers. Removing the need to refactor reduces the likelihood that the code be inadvertently changed as part of debugging (a common cause of Heisenbugs), and is easier to dictate to another programmer.","author":2,"publish_date":"2019-04-11T18:58:28.299899Z","updated_date":"2019-04-11T18:58:28.299921Z"},{"id":3,"title":"PEP 560 -- Core support for typing module and gene","body":"Initially PEP 484 was designed in such way that it would not introduce any changes to the core CPython interpreter. Now type hints and the typing module are extensively used by the community, e.g. PEP 526 and PEP 557 extend the usage of type hints, and the backport of typing on PyPI has 1M downloads/month. Therefore, this restriction can be removed. It is proposed to add two special methods __class_getitem__ and __mro_entries__ to the core CPython for better support of generic types.\r\n\r\nThe restriction to not modify the core CPython interpreter led to some design decisions that became questionable when the typing module started to be widely used. There are three main points of concern: performance of the typing module, metaclass conflicts, and the large number of hacks currently used in typing.","author":2,"publish_date":"2019-04-11T19:01:43.800507Z","updated_date":"2019-04-11T19:01:43.800529Z"},{"id":4,"title":"Money for Nothing","body":"I want my MTV.","author":2,"publish_date":"2019-04-12T20:05:33.188468Z","updated_date":"2019-04-12T20:05:33.188488Z"}]